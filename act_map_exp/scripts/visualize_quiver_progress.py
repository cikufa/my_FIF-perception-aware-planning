#!/usr/bin/env python3
"""Publish FoV optimization quiver iterations as RViz2 markers (ROS 2).

This script reads quiver files generated by FoV optimization
(`quivers_path_yaw.txt` / `quivers.txt`) and animates iteration progress in
RViz. It publishes:
- initial path (static)
- final path (static)
- current iteration path (animated)
- current view-direction arrows (animated)
- optional point cloud from `trajectory_pointcloud.csv` (static)
"""

import argparse
from pathlib import Path
from typing import List, Sequence

import numpy as np
try:
    import rclpy
    from rclpy.node import Node
    from geometry_msgs.msg import Point
    from std_msgs.msg import ColorRGBA
    from visualization_msgs.msg import Marker, MarkerArray
except ImportError as exc:
    raise SystemExit(
        "ROS 2 Python packages are missing (rclpy/geometry_msgs/visualization_msgs). "
        "Source your ROS 2 workspace before running this script."
    ) from exc


def make_color(r: float, g: float, b: float, a: float) -> ColorRGBA:
    msg = ColorRGBA()
    msg.r = float(r)
    msg.g = float(g)
    msg.b = float(b)
    msg.a = float(a)
    return msg


def np_to_point(xyz: np.ndarray) -> Point:
    msg = Point()
    msg.x = float(xyz[0])
    msg.y = float(xyz[1])
    msg.z = float(xyz[2])
    return msg


def marker_base(frame: str, ns: str, marker_id: int, marker_type: int, stamp) -> Marker:
    marker = Marker()
    marker.header.frame_id = frame
    marker.header.stamp = stamp
    marker.ns = ns
    marker.id = marker_id
    marker.type = marker_type
    marker.action = Marker.ADD
    marker.pose.orientation.w = 1.0
    # Lifetime left at default (0 => forever) for RViz.
    return marker


def resolve_run_dir(
    run_dir: str,
    trace_root: str,
    view: str,
    variant: str,
    path_yaw: bool,
) -> Path:
    if run_dir:
        return Path(run_dir).expanduser().resolve()
    suffix = "optimized_path_yaw" if path_yaw else "optimized"
    return Path(trace_root).expanduser().resolve() / view / f"{view}_{variant}" / suffix


def resolve_quiver_file(run_dir: Path) -> Path:
    cands = [
        run_dir / "quivers_path_yaw.txt",
        run_dir / "quivers.txt",
        run_dir / "initial_quivers_path_yaw.txt",
        run_dir / "initial_quivers.txt",
    ]
    for c in cands:
        if c.exists():
            return c
    raise FileNotFoundError(f"No quiver file found under {run_dir}")


def parse_quiver_iterations(path: Path) -> np.ndarray:
    blocks: List[np.ndarray] = []
    cur: List[List[float]] = []
    with path.open("r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line:
                if cur:
                    blocks.append(np.asarray(cur, dtype=float))
                    cur = []
                continue
            parts = [p.strip() for p in line.split(",") if p.strip()]
            if len(parts) >= 6:
                cur.append([float(v) for v in parts[:6]])
    if cur:
        blocks.append(np.asarray(cur, dtype=float))

    if not blocks:
        raise RuntimeError(f"No iteration blocks found in {path}")

    min_n_pose = min(len(b) for b in blocks)
    blocks = [b[:min_n_pose] for b in blocks]
    return np.stack(blocks, axis=0)


def load_points(path: Path, stride: int, max_points: int, seed: int = 7) -> np.ndarray:
    if not path.exists():
        return np.empty((0, 3), dtype=float)
    pts = np.loadtxt(path, delimiter=",", usecols=(0, 1, 2), dtype=float)
    if pts.ndim == 1:
        pts = pts[None, :]
    if stride > 1:
        pts = pts[::stride]
    if max_points > 0 and pts.shape[0] > max_points:
        rng = np.random.default_rng(seed)
        idx = rng.choice(pts.shape[0], size=max_points, replace=False)
        pts = pts[idx]
    return pts


def parse_args() -> argparse.Namespace:
    default_trace = Path(__file__).resolve().parents[1] / "trace"
    parser = argparse.ArgumentParser(
        description="Animate FoV optimization quiver iterations in RViz."
    )

    parser.add_argument("--run-dir", default="",
                        help="Direct path to optimized/optimized_path_yaw folder.")
    parser.add_argument("--trace-root", default=str(default_trace),
                        help="Trace root used with --view/--variant.")
    parser.add_argument("--view", default="top", choices=["top", "diagonal", "bottom"],
                        help="View folder under trace root.")
    parser.add_argument("--variant", default="none",
                        help="Variant suffix in <view>_<variant> (default: none).")
    yaw_group = parser.add_mutually_exclusive_group()
    yaw_group.add_argument("--path-yaw", dest="path_yaw", action="store_true",
                           help="Use optimized_path_yaw (default).")
    yaw_group.add_argument("--normal", dest="path_yaw", action="store_false",
                           help="Use optimized.")
    parser.set_defaults(path_yaw=True)

    parser.add_argument("--quivers", default="",
                        help="Optional direct path to quivers file.")
    parser.add_argument("--points", default="",
                        help="Optional direct path to trajectory_pointcloud.csv.")

    parser.add_argument("--frame", default="world", help="RViz fixed frame.")
    parser.add_argument("--topic", default="stamped_pose_viz",
                        help="MarkerArray topic.")
    parser.add_argument("--namespace", default="fov_opt_progress",
                        help="Marker namespace prefix.")

    parser.add_argument("--rate", type=float, default=2.0,
                        help="Playback rate in Hz.")
    parser.add_argument("--start-iter", type=int, default=0,
                        help="First iteration to display.")
    parser.add_argument("--end-iter", type=int, default=-1,
                        help="Last iteration to display (-1 means final).")
    parser.add_argument("--no-loop", action="store_true",
                        help="Play once and stop at last iteration.")

    parser.add_argument("--point-stride", type=int, default=4,
                        help="Stride for trajectory_pointcloud.csv subsampling.")
    parser.add_argument("--max-points", type=int, default=6000,
                        help="Max points shown in RViz (after stride).")
    parser.add_argument("--hide-pointcloud", action="store_true",
                        help="Do not show point cloud marker.")

    parser.add_argument("--arrow-scale", type=float, default=0.05,
                        help="Arrow length as ratio of trajectory bounding-box diagonal.")
    parser.add_argument("--path-width-scale", type=float, default=0.006,
                        help="Path width as ratio of trajectory bounding-box diagonal.")
    return parser.parse_args()


def build_static_markers(
    frame: str,
    ns_prefix: str,
    all_pos: np.ndarray,
    points: np.ndarray,
    path_width: float,
    show_pointcloud: bool,
    stamp,
) -> List[Marker]:
    markers: List[Marker] = []
    color_init = make_color(0.45, 0.45, 0.45, 0.55)
    color_final = make_color(0.00, 0.65, 0.35, 0.85)

    init_path = marker_base(frame, f"{ns_prefix}_path", 1, Marker.LINE_STRIP, stamp)
    init_path.scale.x = path_width
    init_path.color = color_init
    init_path.points = [np_to_point(xyz) for xyz in all_pos[0]]
    markers.append(init_path)

    final_path = marker_base(frame, f"{ns_prefix}_path", 2, Marker.LINE_STRIP, stamp)
    final_path.scale.x = path_width
    final_path.color = color_final
    final_path.points = [np_to_point(xyz) for xyz in all_pos[-1]]
    markers.append(final_path)

    if show_pointcloud and points.size > 0:
        cloud = marker_base(frame, f"{ns_prefix}_cloud", 0, Marker.POINTS, stamp)
        cloud.scale.x = path_width * 0.55
        cloud.scale.y = path_width * 0.55
        cloud.color = make_color(0.60, 0.60, 0.60, 0.35)
        cloud.points = [np_to_point(xyz) for xyz in points]
        markers.append(cloud)

    return markers


def build_dynamic_markers(
    frame: str,
    ns_prefix: str,
    pos_it: np.ndarray,
    dir_it: np.ndarray,
    iter_id: int,
    last_iter: int,
    arrow_len: float,
    path_width: float,
    text_height: float,
    stamp,
) -> List[Marker]:
    markers: List[Marker] = []
    color_curr = make_color(0.08, 0.56, 1.00, 0.95)
    color_view = make_color(1.00, 0.25, 0.15, 0.90)
    color_pose = make_color(0.95, 0.95, 1.00, 0.90)

    curr_path = marker_base(frame, f"{ns_prefix}_path", 3, Marker.LINE_STRIP, stamp)
    curr_path.scale.x = path_width * 1.35
    curr_path.color = color_curr
    curr_path.points = [np_to_point(xyz) for xyz in pos_it]
    markers.append(curr_path)

    pose_pts = marker_base(frame, f"{ns_prefix}_pose", 5, Marker.SPHERE_LIST, stamp)
    pose_pts.scale.x = path_width * 1.8
    pose_pts.scale.y = path_width * 1.8
    pose_pts.scale.z = path_width * 1.8
    pose_pts.color = color_pose
    pose_pts.points = [np_to_point(xyz) for xyz in pos_it]
    markers.append(pose_pts)

    view_marker = marker_base(frame, f"{ns_prefix}_view", 4, Marker.LINE_LIST, stamp)
    view_marker.scale.x = path_width * 0.7
    view_marker.color = color_view
    for xyz, d in zip(pos_it, dir_it):
        dn = d / (np.linalg.norm(d) + 1e-9)
        p0 = np_to_point(xyz)
        p1 = np_to_point(xyz + dn * arrow_len)
        view_marker.points.extend([p0, p1])
        view_marker.colors.extend([color_view, color_view])
    markers.append(view_marker)

    text = marker_base(frame, f"{ns_prefix}_text", 6, Marker.TEXT_VIEW_FACING, stamp)
    text.scale.z = text_height
    text.color = make_color(1.0, 1.0, 1.0, 0.95)
    text.pose.position = np_to_point(pos_it[0])
    text.pose.position.z += text_height * 1.2
    text.text = f"iter {iter_id}/{last_iter} | poses {pos_it.shape[0]}"
    markers.append(text)

    return markers


def publish_delete_all(pub, frame: str, ns: str, stamp) -> None:
    marker = marker_base(frame, ns, 9999, Marker.CUBE, stamp)
    marker.action = Marker.DELETEALL
    msg = MarkerArray()
    msg.markers.append(marker)
    pub.publish(msg)


def main() -> None:
    args = parse_args()
    rclpy.init()
    node = Node("fov_opt_progress_viz")

    run_dir = resolve_run_dir(
        run_dir=args.run_dir,
        trace_root=args.trace_root,
        view=args.view,
        variant=args.variant,
        path_yaw=args.path_yaw,
    )
    if not run_dir.exists():
        raise FileNotFoundError(f"Run directory does not exist: {run_dir}")

    quivers_path = Path(args.quivers) if args.quivers else resolve_quiver_file(run_dir)
    raw = parse_quiver_iterations(quivers_path)

    points_path = Path(args.points) if args.points else run_dir / "trajectory_pointcloud.csv"
    points = load_points(points_path, stride=max(1, args.point_stride), max_points=args.max_points)

    pos = raw[:, :, :3]
    dirs = raw[:, :, 3:6]
    n_iter, n_pose, _ = pos.shape

    start_iter = max(0, args.start_iter)
    end_iter = n_iter - 1 if args.end_iter < 0 else min(n_iter - 1, args.end_iter)
    if start_iter > end_iter:
        raise ValueError(f"start-iter ({start_iter}) must be <= end-iter ({end_iter})")
    iter_ids = list(range(start_iter, end_iter + 1))

    all_positions = pos.reshape(-1, 3)
    extent = all_positions.max(axis=0) - all_positions.min(axis=0)
    diag = float(np.linalg.norm(extent))
    if diag < 1e-6:
        diag = 1.0

    path_width = max(0.02, diag * max(0.001, args.path_width_scale))
    arrow_len = max(path_width * 3.0, diag * max(0.005, args.arrow_scale))
    text_height = max(path_width * 3.5, diag * 0.03)

    pub = node.create_publisher(MarkerArray, args.topic, 1)
    rclpy.spin_once(node, timeout_sec=0.1)
    stamp = node.get_clock().now().to_msg()
    publish_delete_all(pub, args.frame, args.namespace, stamp)
    rclpy.spin_once(node, timeout_sec=0.1)

    static_markers = build_static_markers(
        frame=args.frame,
        ns_prefix=args.namespace,
        all_pos=pos,
        points=points,
        path_width=path_width,
        show_pointcloud=(not args.hide_pointcloud),
        stamp=stamp,
    )

    node.get_logger().info("FoV quiver progress visualization")
    node.get_logger().info(f"- run_dir: {run_dir}")
    node.get_logger().info(f"- quivers: {quivers_path}")
    node.get_logger().info(f"- iterations: {n_iter} (showing {start_iter}..{end_iter})")
    node.get_logger().info(f"- poses per iteration: {n_pose}")
    node.get_logger().info(f"- points shown: {points.shape[0]}")
    node.get_logger().info(f"- topic: {args.topic}")

    rate_hz = max(0.1, float(args.rate))
    rate = node.create_rate(rate_hz)

    idx = 0
    while rclpy.ok():
        iter_id = iter_ids[idx]
        stamp = node.get_clock().now().to_msg()
        dynamic_markers = build_dynamic_markers(
            frame=args.frame,
            ns_prefix=args.namespace,
            pos_it=pos[iter_id],
            dir_it=dirs[iter_id],
            iter_id=iter_id,
            last_iter=n_iter - 1,
            arrow_len=arrow_len,
            path_width=path_width,
            text_height=text_height,
            stamp=stamp,
        )

        msg = MarkerArray()
        msg.markers.extend(static_markers)
        msg.markers.extend(dynamic_markers)
        pub.publish(msg)

        if idx == len(iter_ids) - 1:
            if args.no_loop:
                node.get_logger().info(
                    f"Reached final displayed iteration {iter_id}. Holding markers."
                )
                break
            idx = 0
        else:
            idx += 1
        rclpy.spin_once(node, timeout_sec=0.0)
        rate.sleep()

    rclpy.spin(node)
    node.destroy_node()
    rclpy.shutdown()


if __name__ == "__main__":
    main()
